
###### 53. 最大子序和
  给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

- 最优解:
  该算法更为简便之处是忽略了对子序列的寻找比较,而是根据规律直接找出最佳答案.
  对于含有正数的序列而言,最大子序列肯定是正数,所以头尾肯定都是正数.我们可以从第一个正数开始算起,每往后加一个数便更新一次和的最大值;当当前和成为负数时,则表明此前序列无法为后面提供最大子序列和,因此必须重新确定序列首项.
  通过临时变量记录和，如果和出现负数，说明前序列无法怎么加，都不会出现最大值了，所以会重新更新临时变量。
  可以理解为，每次为sum出现负数时，为分段的标志，求助每段的最大值。

###### 217. 存在重复元素
  如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

- 最优解:先排序，循环挨个对比,但问题在于排序，Arrays.sort()如何进行排序
